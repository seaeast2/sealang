Sea lang specification.


==TOKEN================================================================ 
<IMPORT> : import 
<VOID> : void 
<UNSIGNED> : unsigned 
<BOOL> : bool
<CHAR> : char 
<SHORT> : short 
<INT> : int 
<LONG> : long 
<CLASS> : class 
<FLOAT> : float 
<DOUBLE> : double
<STATIC> : static 
<IDENTIFIER> : [a-zA-Z][a-zA-Z0-9]* 
<INTEGER> : [0-9]* 
<CHARACTER> : [a-zA-Z0-9]  \\ 'A'
<STRING> : "\""[a-zA-Z0-9]*"\""  \\ "test"
<EOF> : End of file 
<TYPEDEF> : typedef 
<IF> : if 
<WHILE> : while 
<FOR> : for 
<BREAK> : break 
<RETURN> : return 
<SIZEOF> : sizeof 

==DECLARATION========================================================= 
compilation_unit 
  : import_stmts top_defs <EOF> 

typeref_base  
  : <VOID> 
    | <CHAR> 
    | <SHORT> 
    | <INT> 
    | <LONG> 
    | <UNSIGNED> <CHAR> 
    | <UNSIGNED> <SHORT> 
    | <UNSIGNED> <INT> 
    | <UNSIGNED> <LONG> 
    | <FLOAT> 
    | <DOUBLE>
    | <CLASS> <IDENTIFIER> 

import_stmts  
  : (import_stmt)* 

import_stmt 
  : <IMPORT> name ("." name)* ";" 

name 
  : <IDENTIFIER> 

top_defs // top definitions 
  : ( deffunc 
    | defvars 
    | defconst 
    | defclass 
    | typedef )* 

defvars // variable definition. ex) int a = 0, b=19; 
  : storage type name ["=" expr] [("," name ["=" expr])*] ";" 

storage 
  : [<STATIC>] 

deffunc // function definition 
  : storage typeref name "(" params ")" block 

params // parameter definition 
  : <VOID> 
  | fixedparams ["," "..."] 

fixedparams // fixed parameter definition 
  : param ("," param)* 

param 
  : type name 

block 
  : "{" defvar_list stmts "}" 

defclass // class definition 
  : <CLASS> name member_list ";" 

member_list //  
  : "{" (class_member ";")* "}" 

class_member // class member definition 
  : type name 
  | deffunc

typedef // ex) typedef int i32; 
  : <TYPEDEF> typeref <IDENTIFIER> ";" 

type 
  : typeref 

typeref 
  : typeref_base  ( "[""]"                    // unassigned array
                  | "["<INTEGER>"]"           // assigned array
                  | "*"                       // pointer 
                  | "(" param_typerefs ")")*  // function pointer 

param_typerefs // function pointer param type definition 
  : <VOID> 
  | type ("," type)* ["," "..."] 
 

stmts 
  : (stmt)* 

stmt 
  :";" 
  | labeled_stmt 
  | expr ";" 
  | block 
  | if_stmt 
  | while_stmt 
  | dowhile_stmt 
  | for_stmt 
  | switch_stmt 
  | break_stmt 
  | continue_stmt 
  | goto_stmt 
  | return_stmt 

if_stmt  
  : <IF> "(" expr ")" stmt [<ELSE> stmt] 

while_stmt 
  : <WHILE> "(" expr ")" stmt 

for_stmt 
  : <FOR> "(" [expr] ";" [expr] ";" [expr] ")" stmt 

break_stmt 
  : <BREAK> ";" 

return_stmt 
  : <RETURN> ";" 
  | <RETURN> expr ";" 

expr 
  : term "=" rhs_expr 
  | term opassign_op expr 
  | expr10 

opassign_op 
  : "+=" 
  | "-=" 
  | "*=" 
  | "/=" 
  | "%=" 
  | "&=" 
  | "|=" 
  | "^=" 
  | "<<=" 
  | ">>=" 

Operator priority 
+-----------+--------------------+
| Priority  |      Operator      |
+-----------+--------------------+
|    10     |         ? :        |
+-----------+--------------------+
|     9     |         ||         |
+-----------+--------------------+
|     8     |         &&         |
+-----------+--------------------+
|     7     |  >, <, >=, ==, !=  |
+-----------+--------------------+
|     6     |     | (bit op)     |
+-----------+--------------------+
|     5     |     ^ (bit op)     |
+-----------+--------------------+
|     4     |     & (bit op)     |
+-----------+--------------------+
|     3     |      >>, <<        |
+-----------+--------------------+
|     2     |       +, -         |
+-----------+--------------------+
|     1     |     *, /, %        |
+-----------+--------------------+

expr10 
  : expr9 ["?" expr() ":" expr10] 

expr9 
  : expr8 ("||" expr8)* 

expr8 
  : expr7 ("&&" expr7)* 

expr7  
  : expr7 (   ">" expr6  
             | "<" expr6 
             | ">=" expr6 
             | "<=" expr6 
             | "==" expr6 
             | "!=" expr6 
             )* 

expr6 
  : expr5 ("|" expr5)* 

expr5 
  : expr4 ("^" expr4)* 

expr4 
  : expr3 ("&" expr3)* 

expr3 
  : expr2 ( ">>" expr2 | "<<" expr2)* 

expr2 
  : expr1 ( "+" expr1 | "-" expr1)* 

expr1 
  : term ( "*" term  
  | "/" term 
  | "%" term 
  )* 

term 
  : "(" type ")" term          // type casting 
  | unary 

unary 
  : "++" unary                 // pre ++ 
  | "--" unary                 // pre -- 
  | "+" term                   // unary +, positive 
  | "-" term                   // unary -, negative 
  | "!" term                   // Logical negation 
  | "*" term                   // Pointer reference 
  | "&" term                   // adress operator 
  | <SIZEOF> "(" type ")"      // sizeof(type) 
  | <SIZEOF> unary             // sizeof unary 
  | postfix                    // postfix  

postfix 
  : primary ("++"              // post ++ 
            |"--"               // post -- 
            |"[" expr "]"       // array reference 
            |"." name           // class member reference 
            |"->" name          // class member pointer reference 
            |"(" args ")"       // function call 
            )* 

args 
  : [expr ("," expr)*] 

primary 
  : <INTEGER> 
  |<CHARACTER> 
  |<STRING> 
  |<IDENTIFIER> 
  |"(" expr ")" 



AST Node Tree =================================================================
BaseNode
  RootNode : Abstract Syntax tree root
  ExprNode : Expression node
    AbstractAssignNode : Assign
      AssignNode : Assign (=)
      OpAssignNode : Operation Assign (+=, -=, ...) 
    AddressNode : Address expression (&x)
    BinaryOpNode : Binary operaton (x+y, x-y, ...)
      LogicalAndNode : &&
      LogicalOrNode : ||
    CastNode : type casting ( int(a), ...)
    CondExprNode : Ternary Operation ( a? b : c)
    FuncCallNode : Function call
    LHSNode : Left side of assignment expression.
      ArrayRefNode : Array reference (a[3]);
      DereferenceNode : Pointer reference (*ptr)
      MemberRefNode : Class member reference (s.a1)
      PtrMemberRefNode : Pointer class member reference (s->a1)
      VariableNode : Variable
    LiteralNode : Literal
      IntegerLiteralNode : Interger literal
      RealLiteralNode : Real literal (1.4444)
      StringLiteralNode : String literal
    SizeofExprNode : for sizeof(expression)
    SizeofTypeNode : for sizeof(type)
    UnaryOpNode : Unary operation (+x, -x, ...)
      UnaryArithmeticOpNode : ++, --
        PrefixOpNode : Prefix operation (++x, --x)
        SuffixOpNode : Suffix operation (x++, x--)
    MemberNode : Class member
    StmtNode : Statement node
      BlockNode : Block ( { ... } )
      BreakNode : break
      CaseNode : case label
      ContinueNode : continue
      DoWhileNode : do-while
      ExprStmtNode : Single statement expression
      ForNode : for
      GotoNode : goto
      IfNode : if
      LabelNode : goto label
      ReturnNode : return
      SwitchNode : switch 
      WhileNode : while
  TypeDefinition : Type definition
    CompositeTypeDefinition : Composite type definition
      ClassNode : class type definition
    TypedefNode : typedef
  TypeNode : Node for maintaining type


